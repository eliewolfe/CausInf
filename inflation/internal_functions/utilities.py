#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Utility functions.
"""

from __future__ import absolute_import
import numpy as np
from numba import njit
from scipy.sparse import coo_matrix


def Deduplicate(
        ar):  # Alternatives include unique_everseen and panda.unique, see https://stackoverflow.com/a/15637512 and https://stackoverflow.com/a/41577279
    (vals, idx) = np.unique(ar, return_index=True)
    return vals[np.argsort(idx)]


@njit
def MoveToFront(num_var, ar):
    return np.hstack((ar, np.delete(np.arange(num_var), ar)))


@njit
def MoveToBack(num_var, ar):
    return np.hstack((np.delete(np.arange(num_var), ar), ar))


@njit
def GenShapedColumnIntegers(range_shape):
    return np.arange(0, np.prod(np.array(range_shape)), 1, np.int32).reshape(range_shape)
    #return np.arange(np.array(range_shape).prod()).reshape(range_shape)


# def PositionIndex(arraywithduplicates):
#    arraycopy=np.empty_like(arraywithduplicates)
#    u=np.unique(arraywithduplicates)
#    arraycopy[u]=np.arange(len(u))
#    return arraycopy.take(arraywithduplicates)

def PositionIndex(arraywithduplicates):
    # u,inv,idx=np.unique(arraywithduplicates,return_inverse=True)[1]
    return np.unique(arraywithduplicates, return_inverse=True)[1]


@njit
def reindex_list(ar):
    seenbefore = np.full(np.max(ar) + 1, -1)
    newlist = np.empty(len(ar), np.uint)
    currentindex = 0
    for idx, val in enumerate(ar):
        if seenbefore[val] == -1:
            seenbefore[val] = currentindex
            newlist[idx] = currentindex
            currentindex += 1
        else:
            newlist[idx] = seenbefore[val]
    return newlist

def SparseMatrixFromRowsPerColumn(OnesPositions, sort_columns=True):
    #Assumes that OnesPositions is a 2d numpy array of integers.
    #First dimension indicates which ORBIT we are considering.
    #Second dimension indicates which COLUMN we are listing rows for.
    columncount = OnesPositions.shape[-1]
    rowcount = int(np.amax(OnesPositions)) + 1
    if sort_columns:
        ar_to_broadcast = np.lexsort(OnesPositions)
    else:
        ar_to_broadcast = np.arange(columncount)
    columnspec = np.broadcast_to(ar_to_broadcast, OnesPositions.shape).ravel()
    return coo_matrix((np.ones(OnesPositions.size, np.uint), (OnesPositions.ravel(), columnspec)),
                      (rowcount, columncount), dtype=np.uint)
@njit
def Is_vec_in_mat(vec, mat):
    assume = True
    for elem in mat:
        if np.array_equal(vec, elem):
            assume = False
            break
    return assume


@njit
def dimino_wolfe(group_generators):
    gens = group_generators
    degree = np.max(gens) + 1
    idn = np.arange(degree)
    order = 0
    element_list = [idn]
    # element_list=np.atleast_2d(idn)
    # set_element_list = {tuple(idn)}
    for i in np.arange(len(gens)):
        # D elements of the subgroup G_i generated by gens[:i]
        D = element_list[:]
        N = [idn]
        while N:
            A = N
            N = []
            for a in A:
                for g in gens[:i + 1]:
                    ag = a[g]
                    if Is_vec_in_mat(ag, element_list):
                        # if not np.any(np.all(ag==np.array(element_list,np.int64),axis=1)):
                        # if ag not in np.array(element_list):
                        # if tuple(ag) not in set_element_list:
                        # produce G_i*g
                        for d in D:
                            order += 1
                            ap = d[ag]
                            element_list.append(ap)
                            # element_list=np.append(element_list, np.atleast_2d(ap), axis=0)
                            # set_element_list.add(tuple(ap))
                            N.append(ap)
    return element_list

if __name__ == '__main__':
    print(SparseMatrixFromRowsPerColumn(np.array([[1,1,3],[2,5,3]])).tocsr())